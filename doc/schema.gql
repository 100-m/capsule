schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

input approve_args {
  instrument_id: Int
}

"""
columns and relationships of "bond"
"""
type bond {
  """This is a country description"""
  country: String!
  """This is a country description"""
  currency: String!
  """This is a country description"""
  id: Int!
  """This is a country description"""
  maturity_date: timestamptz!
  name: String!
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String!
  uid: String!
  update_date: timestamptz!
  update_user_id: Int!
}

"""
aggregated selection of "bond"
"""
type bond_aggregate {
  aggregate: bond_aggregate_fields
  nodes: [bond!]!
}

"""
aggregate fields of "bond"
"""
type bond_aggregate_fields {
  avg: bond_avg_fields
  count(columns: [bond_select_column!], distinct: Boolean): Int!
  max: bond_max_fields
  min: bond_min_fields
  stddev: bond_stddev_fields
  stddev_pop: bond_stddev_pop_fields
  stddev_samp: bond_stddev_samp_fields
  sum: bond_sum_fields
  var_pop: bond_var_pop_fields
  var_samp: bond_var_samp_fields
  variance: bond_variance_fields
}

"""aggregate avg on columns"""
type bond_avg_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""
Boolean expression to filter rows from the table "bond". All fields are combined with a logical 'AND'.
"""
input bond_bool_exp {
  _and: [bond_bool_exp!]
  _not: bond_bool_exp
  _or: [bond_bool_exp!]
  country: String_comparison_exp
  currency: String_comparison_exp
  id: Int_comparison_exp
  maturity_date: timestamptz_comparison_exp
  name: String_comparison_exp
  resolution_date: timestamptz_comparison_exp
  resolution_status: String_comparison_exp
  resolution_user_id: Int_comparison_exp
  source: String_comparison_exp
  uid: String_comparison_exp
  update_date: timestamptz_comparison_exp
  update_user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "bond"
"""
enum bond_constraint {
  """unique or primary key constraint"""
  PK_bond_id

  """unique or primary key constraint"""
  bond_unique
}

"""
input type for incrementing numeric columns in table "bond"
"""
input bond_inc_input {
  id: Int
  resolution_user_id: Int
  update_user_id: Int
}

"""
input type for inserting data into table "bond"
"""
input bond_insert_input {
  country: String
  currency: String
  id: Int
  maturity_date: timestamptz
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate max on columns"""
type bond_max_fields {
  country: String
  currency: String
  id: Int
  maturity_date: timestamptz
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate min on columns"""
type bond_min_fields {
  country: String
  currency: String
  id: Int
  maturity_date: timestamptz
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""
response of any mutation on the table "bond"
"""
type bond_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [bond!]!
}

"""
on conflict condition type for table "bond"
"""
input bond_on_conflict {
  constraint: bond_constraint!
  update_columns: [bond_update_column!]! = []
  where: bond_bool_exp
}

"""Ordering options when selecting data from "bond"."""
input bond_order_by {
  country: order_by
  currency: order_by
  id: order_by
  maturity_date: order_by
  name: order_by
  resolution_date: order_by
  resolution_status: order_by
  resolution_user_id: order_by
  source: order_by
  uid: order_by
  update_date: order_by
  update_user_id: order_by
}

"""primary key columns input for table: bond"""
input bond_pk_columns_input {
  id: Int!
}

"""
select columns of table "bond"
"""
enum bond_select_column {
  """column name"""
  country

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  maturity_date

  """column name"""
  name

  """column name"""
  resolution_date

  """column name"""
  resolution_status

  """column name"""
  resolution_user_id

  """column name"""
  source

  """column name"""
  uid

  """column name"""
  update_date

  """column name"""
  update_user_id
}

"""
input type for updating data in table "bond"
"""
input bond_set_input {
  country: String
  currency: String
  id: Int
  maturity_date: timestamptz
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate stddev on columns"""
type bond_stddev_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate stddev_pop on columns"""
type bond_stddev_pop_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate stddev_samp on columns"""
type bond_stddev_samp_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate sum on columns"""
type bond_sum_fields {
  id: Int
  resolution_user_id: Int
  update_user_id: Int
}

"""
update columns of table "bond"
"""
enum bond_update_column {
  """column name"""
  country

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  maturity_date

  """column name"""
  name

  """column name"""
  resolution_date

  """column name"""
  resolution_status

  """column name"""
  resolution_user_id

  """column name"""
  source

  """column name"""
  uid

  """column name"""
  update_date

  """column name"""
  update_user_id
}

"""aggregate var_pop on columns"""
type bond_var_pop_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate var_samp on columns"""
type bond_var_samp_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate variance on columns"""
type bond_variance_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""
columns and relationships of "coupon"
"""
type coupon {
  bond_id: Int!
  coupon: float8!
  currency: String!
  date: timestamptz!
  id: Int!
}

"""
aggregated selection of "coupon"
"""
type coupon_aggregate {
  aggregate: coupon_aggregate_fields
  nodes: [coupon!]!
}

"""
aggregate fields of "coupon"
"""
type coupon_aggregate_fields {
  avg: coupon_avg_fields
  count(columns: [coupon_select_column!], distinct: Boolean): Int!
  max: coupon_max_fields
  min: coupon_min_fields
  stddev: coupon_stddev_fields
  stddev_pop: coupon_stddev_pop_fields
  stddev_samp: coupon_stddev_samp_fields
  sum: coupon_sum_fields
  var_pop: coupon_var_pop_fields
  var_samp: coupon_var_samp_fields
  variance: coupon_variance_fields
}

"""aggregate avg on columns"""
type coupon_avg_fields {
  bond_id: Float
  coupon: Float
  id: Float
}

"""
Boolean expression to filter rows from the table "coupon". All fields are combined with a logical 'AND'.
"""
input coupon_bool_exp {
  _and: [coupon_bool_exp!]
  _not: coupon_bool_exp
  _or: [coupon_bool_exp!]
  bond_id: Int_comparison_exp
  coupon: float8_comparison_exp
  currency: String_comparison_exp
  date: timestamptz_comparison_exp
  id: Int_comparison_exp
}

"""
unique or primary key constraints on table "coupon"
"""
enum coupon_constraint {
  """unique or primary key constraint"""
  PK_coupon_id
}

"""
input type for incrementing numeric columns in table "coupon"
"""
input coupon_inc_input {
  bond_id: Int
  coupon: float8
  id: Int
}

"""
input type for inserting data into table "coupon"
"""
input coupon_insert_input {
  bond_id: Int
  coupon: float8
  currency: String
  date: timestamptz
  id: Int
}

"""aggregate max on columns"""
type coupon_max_fields {
  bond_id: Int
  coupon: float8
  currency: String
  date: timestamptz
  id: Int
}

"""aggregate min on columns"""
type coupon_min_fields {
  bond_id: Int
  coupon: float8
  currency: String
  date: timestamptz
  id: Int
}

"""
response of any mutation on the table "coupon"
"""
type coupon_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [coupon!]!
}

"""
on conflict condition type for table "coupon"
"""
input coupon_on_conflict {
  constraint: coupon_constraint!
  update_columns: [coupon_update_column!]! = []
  where: coupon_bool_exp
}

"""Ordering options when selecting data from "coupon"."""
input coupon_order_by {
  bond_id: order_by
  coupon: order_by
  currency: order_by
  date: order_by
  id: order_by
}

"""primary key columns input for table: coupon"""
input coupon_pk_columns_input {
  id: Int!
}

"""
select columns of table "coupon"
"""
enum coupon_select_column {
  """column name"""
  bond_id

  """column name"""
  coupon

  """column name"""
  currency

  """column name"""
  date

  """column name"""
  id
}

"""
input type for updating data in table "coupon"
"""
input coupon_set_input {
  bond_id: Int
  coupon: float8
  currency: String
  date: timestamptz
  id: Int
}

"""aggregate stddev on columns"""
type coupon_stddev_fields {
  bond_id: Float
  coupon: Float
  id: Float
}

"""aggregate stddev_pop on columns"""
type coupon_stddev_pop_fields {
  bond_id: Float
  coupon: Float
  id: Float
}

"""aggregate stddev_samp on columns"""
type coupon_stddev_samp_fields {
  bond_id: Float
  coupon: Float
  id: Float
}

"""aggregate sum on columns"""
type coupon_sum_fields {
  bond_id: Int
  coupon: float8
  id: Int
}

"""
update columns of table "coupon"
"""
enum coupon_update_column {
  """column name"""
  bond_id

  """column name"""
  coupon

  """column name"""
  currency

  """column name"""
  date

  """column name"""
  id
}

"""aggregate var_pop on columns"""
type coupon_var_pop_fields {
  bond_id: Float
  coupon: Float
  id: Float
}

"""aggregate var_samp on columns"""
type coupon_var_samp_fields {
  bond_id: Float
  coupon: Float
  id: Float
}

"""aggregate variance on columns"""
type coupon_variance_fields {
  bond_id: Float
  coupon: Float
  id: Float
}

"""
columns and relationships of "equity"
"""
type equity {
  country: String!
  currency: String!
  id: Int!
  issuer: String!
  name: String!
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  share_number: Int!
  source: String!
  uid: String!
  update_date: timestamptz!
  update_user_id: Int!
}

"""
aggregated selection of "equity"
"""
type equity_aggregate {
  aggregate: equity_aggregate_fields
  nodes: [equity!]!
}

"""
aggregate fields of "equity"
"""
type equity_aggregate_fields {
  avg: equity_avg_fields
  count(columns: [equity_select_column!], distinct: Boolean): Int!
  max: equity_max_fields
  min: equity_min_fields
  stddev: equity_stddev_fields
  stddev_pop: equity_stddev_pop_fields
  stddev_samp: equity_stddev_samp_fields
  sum: equity_sum_fields
  var_pop: equity_var_pop_fields
  var_samp: equity_var_samp_fields
  variance: equity_variance_fields
}

"""aggregate avg on columns"""
type equity_avg_fields {
  id: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""
Boolean expression to filter rows from the table "equity". All fields are combined with a logical 'AND'.
"""
input equity_bool_exp {
  _and: [equity_bool_exp!]
  _not: equity_bool_exp
  _or: [equity_bool_exp!]
  country: String_comparison_exp
  currency: String_comparison_exp
  id: Int_comparison_exp
  issuer: String_comparison_exp
  name: String_comparison_exp
  resolution_date: timestamptz_comparison_exp
  resolution_status: String_comparison_exp
  resolution_user_id: Int_comparison_exp
  share_number: Int_comparison_exp
  source: String_comparison_exp
  uid: String_comparison_exp
  update_date: timestamptz_comparison_exp
  update_user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "equity"
"""
enum equity_constraint {
  """unique or primary key constraint"""
  PK_equity_id

  """unique or primary key constraint"""
  equity_unique
}

"""
input type for incrementing numeric columns in table "equity"
"""
input equity_inc_input {
  id: Int
  resolution_user_id: Int
  share_number: Int
  update_user_id: Int
}

"""
input type for inserting data into table "equity"
"""
input equity_insert_input {
  country: String
  currency: String
  id: Int
  issuer: String
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  share_number: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate max on columns"""
type equity_max_fields {
  country: String
  currency: String
  id: Int
  issuer: String
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  share_number: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate min on columns"""
type equity_min_fields {
  country: String
  currency: String
  id: Int
  issuer: String
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  share_number: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""
response of any mutation on the table "equity"
"""
type equity_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [equity!]!
}

"""
on conflict condition type for table "equity"
"""
input equity_on_conflict {
  constraint: equity_constraint!
  update_columns: [equity_update_column!]! = []
  where: equity_bool_exp
}

"""Ordering options when selecting data from "equity"."""
input equity_order_by {
  country: order_by
  currency: order_by
  id: order_by
  issuer: order_by
  name: order_by
  resolution_date: order_by
  resolution_status: order_by
  resolution_user_id: order_by
  share_number: order_by
  source: order_by
  uid: order_by
  update_date: order_by
  update_user_id: order_by
}

"""primary key columns input for table: equity"""
input equity_pk_columns_input {
  id: Int!
}

"""
select columns of table "equity"
"""
enum equity_select_column {
  """column name"""
  country

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  issuer

  """column name"""
  name

  """column name"""
  resolution_date

  """column name"""
  resolution_status

  """column name"""
  resolution_user_id

  """column name"""
  share_number

  """column name"""
  source

  """column name"""
  uid

  """column name"""
  update_date

  """column name"""
  update_user_id
}

"""
input type for updating data in table "equity"
"""
input equity_set_input {
  country: String
  currency: String
  id: Int
  issuer: String
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  share_number: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate stddev on columns"""
type equity_stddev_fields {
  id: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""aggregate stddev_pop on columns"""
type equity_stddev_pop_fields {
  id: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""aggregate stddev_samp on columns"""
type equity_stddev_samp_fields {
  id: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""aggregate sum on columns"""
type equity_sum_fields {
  id: Int
  resolution_user_id: Int
  share_number: Int
  update_user_id: Int
}

"""
update columns of table "equity"
"""
enum equity_update_column {
  """column name"""
  country

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  issuer

  """column name"""
  name

  """column name"""
  resolution_date

  """column name"""
  resolution_status

  """column name"""
  resolution_user_id

  """column name"""
  share_number

  """column name"""
  source

  """column name"""
  uid

  """column name"""
  update_date

  """column name"""
  update_user_id
}

"""aggregate var_pop on columns"""
type equity_var_pop_fields {
  id: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""aggregate var_samp on columns"""
type equity_var_samp_fields {
  id: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""aggregate variance on columns"""
type equity_variance_fields {
  id: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

input golden_args {
  uid: String
}

"""
columns and relationships of "instrument"
"""
type instrument {
  country: String!
  currency: String!
  id: Int!
  name: String!
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String!
  uid: String!
  update_date: timestamptz!
  update_user_id: Int!
}

"""
aggregated selection of "instrument"
"""
type instrument_aggregate {
  aggregate: instrument_aggregate_fields
  nodes: [instrument!]!
}

"""
aggregate fields of "instrument"
"""
type instrument_aggregate_fields {
  avg: instrument_avg_fields
  count(columns: [instrument_select_column!], distinct: Boolean): Int!
  max: instrument_max_fields
  min: instrument_min_fields
  stddev: instrument_stddev_fields
  stddev_pop: instrument_stddev_pop_fields
  stddev_samp: instrument_stddev_samp_fields
  sum: instrument_sum_fields
  var_pop: instrument_var_pop_fields
  var_samp: instrument_var_samp_fields
  variance: instrument_variance_fields
}

"""aggregate avg on columns"""
type instrument_avg_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""
Boolean expression to filter rows from the table "instrument". All fields are combined with a logical 'AND'.
"""
input instrument_bool_exp {
  _and: [instrument_bool_exp!]
  _not: instrument_bool_exp
  _or: [instrument_bool_exp!]
  country: String_comparison_exp
  currency: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  resolution_date: timestamptz_comparison_exp
  resolution_status: String_comparison_exp
  resolution_user_id: Int_comparison_exp
  source: String_comparison_exp
  uid: String_comparison_exp
  update_date: timestamptz_comparison_exp
  update_user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "instrument"
"""
enum instrument_constraint {
  """unique or primary key constraint"""
  PK_instrument_id

  """unique or primary key constraint"""
  instrument_unique
}

"""
input type for incrementing numeric columns in table "instrument"
"""
input instrument_inc_input {
  id: Int
  resolution_user_id: Int
  update_user_id: Int
}

"""
input type for inserting data into table "instrument"
"""
input instrument_insert_input {
  country: String
  currency: String
  id: Int
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate max on columns"""
type instrument_max_fields {
  country: String
  currency: String
  id: Int
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate min on columns"""
type instrument_min_fields {
  country: String
  currency: String
  id: Int
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""
response of any mutation on the table "instrument"
"""
type instrument_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [instrument!]!
}

"""
on conflict condition type for table "instrument"
"""
input instrument_on_conflict {
  constraint: instrument_constraint!
  update_columns: [instrument_update_column!]! = []
  where: instrument_bool_exp
}

"""Ordering options when selecting data from "instrument"."""
input instrument_order_by {
  country: order_by
  currency: order_by
  id: order_by
  name: order_by
  resolution_date: order_by
  resolution_status: order_by
  resolution_user_id: order_by
  source: order_by
  uid: order_by
  update_date: order_by
  update_user_id: order_by
}

"""primary key columns input for table: instrument"""
input instrument_pk_columns_input {
  id: Int!
}

"""
select columns of table "instrument"
"""
enum instrument_select_column {
  """column name"""
  country

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  name

  """column name"""
  resolution_date

  """column name"""
  resolution_status

  """column name"""
  resolution_user_id

  """column name"""
  source

  """column name"""
  uid

  """column name"""
  update_date

  """column name"""
  update_user_id
}

"""
input type for updating data in table "instrument"
"""
input instrument_set_input {
  country: String
  currency: String
  id: Int
  name: String
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate stddev on columns"""
type instrument_stddev_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate stddev_pop on columns"""
type instrument_stddev_pop_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate stddev_samp on columns"""
type instrument_stddev_samp_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate sum on columns"""
type instrument_sum_fields {
  id: Int
  resolution_user_id: Int
  update_user_id: Int
}

"""
update columns of table "instrument"
"""
enum instrument_update_column {
  """column name"""
  country

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  name

  """column name"""
  resolution_date

  """column name"""
  resolution_status

  """column name"""
  resolution_user_id

  """column name"""
  source

  """column name"""
  uid

  """column name"""
  update_date

  """column name"""
  update_user_id
}

"""aggregate var_pop on columns"""
type instrument_var_pop_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate var_samp on columns"""
type instrument_var_samp_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate variance on columns"""
type instrument_variance_fields {
  id: Float
  resolution_user_id: Float
  update_user_id: Float
}

"""mutation root"""
type mutation_root {
  """
  execute VOLATILE function "approve" which returns "instrument"
  """
  approve(
    """
    input parameters for function "approve"
    """
    args: approve_args!

    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): [instrument!]!

  """
  delete data from the table: "bond"
  """
  delete_bond(
    """filter the rows which have to be deleted"""
    where: bond_bool_exp!
  ): bond_mutation_response

  """
  delete single row from the table: "bond"
  """
  delete_bond_by_pk(id: Int!): bond

  """
  delete data from the table: "coupon"
  """
  delete_coupon(
    """filter the rows which have to be deleted"""
    where: coupon_bool_exp!
  ): coupon_mutation_response

  """
  delete single row from the table: "coupon"
  """
  delete_coupon_by_pk(id: Int!): coupon

  """
  delete data from the table: "equity"
  """
  delete_equity(
    """filter the rows which have to be deleted"""
    where: equity_bool_exp!
  ): equity_mutation_response

  """
  delete single row from the table: "equity"
  """
  delete_equity_by_pk(id: Int!): equity

  """
  delete data from the table: "instrument"
  """
  delete_instrument(
    """filter the rows which have to be deleted"""
    where: instrument_bool_exp!
  ): instrument_mutation_response

  """
  delete single row from the table: "instrument"
  """
  delete_instrument_by_pk(id: Int!): instrument

  """
  delete data from the table: "preferred"
  """
  delete_preferred(
    """filter the rows which have to be deleted"""
    where: preferred_bool_exp!
  ): preferred_mutation_response

  """
  delete single row from the table: "preferred"
  """
  delete_preferred_by_pk(id: Int!): preferred

  """
  delete data from the table: "resolution"
  """
  delete_resolution(
    """filter the rows which have to be deleted"""
    where: resolution_bool_exp!
  ): resolution_mutation_response

  """
  insert data into the table: "bond"
  """
  insert_bond(
    """the rows to be inserted"""
    objects: [bond_insert_input!]!

    """on conflict condition"""
    on_conflict: bond_on_conflict
  ): bond_mutation_response

  """
  insert a single row into the table: "bond"
  """
  insert_bond_one(
    """the row to be inserted"""
    object: bond_insert_input!

    """on conflict condition"""
    on_conflict: bond_on_conflict
  ): bond

  """
  insert data into the table: "coupon"
  """
  insert_coupon(
    """the rows to be inserted"""
    objects: [coupon_insert_input!]!

    """on conflict condition"""
    on_conflict: coupon_on_conflict
  ): coupon_mutation_response

  """
  insert a single row into the table: "coupon"
  """
  insert_coupon_one(
    """the row to be inserted"""
    object: coupon_insert_input!

    """on conflict condition"""
    on_conflict: coupon_on_conflict
  ): coupon

  """
  insert data into the table: "equity"
  """
  insert_equity(
    """the rows to be inserted"""
    objects: [equity_insert_input!]!

    """on conflict condition"""
    on_conflict: equity_on_conflict
  ): equity_mutation_response

  """
  insert a single row into the table: "equity"
  """
  insert_equity_one(
    """the row to be inserted"""
    object: equity_insert_input!

    """on conflict condition"""
    on_conflict: equity_on_conflict
  ): equity

  """
  insert data into the table: "instrument"
  """
  insert_instrument(
    """the rows to be inserted"""
    objects: [instrument_insert_input!]!

    """on conflict condition"""
    on_conflict: instrument_on_conflict
  ): instrument_mutation_response

  """
  insert a single row into the table: "instrument"
  """
  insert_instrument_one(
    """the row to be inserted"""
    object: instrument_insert_input!

    """on conflict condition"""
    on_conflict: instrument_on_conflict
  ): instrument

  """
  insert data into the table: "preferred"
  """
  insert_preferred(
    """the rows to be inserted"""
    objects: [preferred_insert_input!]!

    """on conflict condition"""
    on_conflict: preferred_on_conflict
  ): preferred_mutation_response

  """
  insert a single row into the table: "preferred"
  """
  insert_preferred_one(
    """the row to be inserted"""
    object: preferred_insert_input!

    """on conflict condition"""
    on_conflict: preferred_on_conflict
  ): preferred

  """
  insert data into the table: "resolution"
  """
  insert_resolution(
    """the rows to be inserted"""
    objects: [resolution_insert_input!]!
  ): resolution_mutation_response

  """
  insert a single row into the table: "resolution"
  """
  insert_resolution_one(
    """the row to be inserted"""
    object: resolution_insert_input!
  ): resolution

  """
  execute VOLATILE function "reject" which returns "instrument"
  """
  reject(
    """
    input parameters for function "reject"
    """
    args: reject_args!

    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): [instrument!]!

  """
  update data of the table: "bond"
  """
  update_bond(
    """increments the numeric columns with given value of the filtered values"""
    _inc: bond_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: bond_set_input

    """filter the rows which have to be updated"""
    where: bond_bool_exp!
  ): bond_mutation_response

  """
  update single row of the table: "bond"
  """
  update_bond_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: bond_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: bond_set_input
    pk_columns: bond_pk_columns_input!
  ): bond

  """
  update data of the table: "coupon"
  """
  update_coupon(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coupon_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coupon_set_input

    """filter the rows which have to be updated"""
    where: coupon_bool_exp!
  ): coupon_mutation_response

  """
  update single row of the table: "coupon"
  """
  update_coupon_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: coupon_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: coupon_set_input
    pk_columns: coupon_pk_columns_input!
  ): coupon

  """
  update data of the table: "equity"
  """
  update_equity(
    """increments the numeric columns with given value of the filtered values"""
    _inc: equity_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: equity_set_input

    """filter the rows which have to be updated"""
    where: equity_bool_exp!
  ): equity_mutation_response

  """
  update single row of the table: "equity"
  """
  update_equity_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: equity_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: equity_set_input
    pk_columns: equity_pk_columns_input!
  ): equity

  """
  update data of the table: "instrument"
  """
  update_instrument(
    """increments the numeric columns with given value of the filtered values"""
    _inc: instrument_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: instrument_set_input

    """filter the rows which have to be updated"""
    where: instrument_bool_exp!
  ): instrument_mutation_response

  """
  update single row of the table: "instrument"
  """
  update_instrument_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: instrument_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: instrument_set_input
    pk_columns: instrument_pk_columns_input!
  ): instrument

  """
  update data of the table: "preferred"
  """
  update_preferred(
    """increments the numeric columns with given value of the filtered values"""
    _inc: preferred_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: preferred_set_input

    """filter the rows which have to be updated"""
    where: preferred_bool_exp!
  ): preferred_mutation_response

  """
  update single row of the table: "preferred"
  """
  update_preferred_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: preferred_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: preferred_set_input
    pk_columns: preferred_pk_columns_input!
  ): preferred

  """
  update data of the table: "resolution"
  """
  update_resolution(
    """increments the numeric columns with given value of the filtered values"""
    _inc: resolution_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: resolution_set_input

    """filter the rows which have to be updated"""
    where: resolution_bool_exp!
  ): resolution_mutation_response
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "preferred"
"""
type preferred {
  country: String!
  currency: String!
  id: Int!
  issuer: String!
  name: String!
  rate: float8!
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  share_number: Int!
  source: String!
  uid: String!
  update_date: timestamptz!
  update_user_id: Int!
}

"""
aggregated selection of "preferred"
"""
type preferred_aggregate {
  aggregate: preferred_aggregate_fields
  nodes: [preferred!]!
}

"""
aggregate fields of "preferred"
"""
type preferred_aggregate_fields {
  avg: preferred_avg_fields
  count(columns: [preferred_select_column!], distinct: Boolean): Int!
  max: preferred_max_fields
  min: preferred_min_fields
  stddev: preferred_stddev_fields
  stddev_pop: preferred_stddev_pop_fields
  stddev_samp: preferred_stddev_samp_fields
  sum: preferred_sum_fields
  var_pop: preferred_var_pop_fields
  var_samp: preferred_var_samp_fields
  variance: preferred_variance_fields
}

"""aggregate avg on columns"""
type preferred_avg_fields {
  id: Float
  rate: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""
Boolean expression to filter rows from the table "preferred". All fields are combined with a logical 'AND'.
"""
input preferred_bool_exp {
  _and: [preferred_bool_exp!]
  _not: preferred_bool_exp
  _or: [preferred_bool_exp!]
  country: String_comparison_exp
  currency: String_comparison_exp
  id: Int_comparison_exp
  issuer: String_comparison_exp
  name: String_comparison_exp
  rate: float8_comparison_exp
  resolution_date: timestamptz_comparison_exp
  resolution_status: String_comparison_exp
  resolution_user_id: Int_comparison_exp
  share_number: Int_comparison_exp
  source: String_comparison_exp
  uid: String_comparison_exp
  update_date: timestamptz_comparison_exp
  update_user_id: Int_comparison_exp
}

"""
unique or primary key constraints on table "preferred"
"""
enum preferred_constraint {
  """unique or primary key constraint"""
  PK_preferred_id

  """unique or primary key constraint"""
  preferred_unique
}

"""
input type for incrementing numeric columns in table "preferred"
"""
input preferred_inc_input {
  id: Int
  rate: float8
  resolution_user_id: Int
  share_number: Int
  update_user_id: Int
}

"""
input type for inserting data into table "preferred"
"""
input preferred_insert_input {
  country: String
  currency: String
  id: Int
  issuer: String
  name: String
  rate: float8
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  share_number: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate max on columns"""
type preferred_max_fields {
  country: String
  currency: String
  id: Int
  issuer: String
  name: String
  rate: float8
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  share_number: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate min on columns"""
type preferred_min_fields {
  country: String
  currency: String
  id: Int
  issuer: String
  name: String
  rate: float8
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  share_number: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""
response of any mutation on the table "preferred"
"""
type preferred_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [preferred!]!
}

"""
on conflict condition type for table "preferred"
"""
input preferred_on_conflict {
  constraint: preferred_constraint!
  update_columns: [preferred_update_column!]! = []
  where: preferred_bool_exp
}

"""Ordering options when selecting data from "preferred"."""
input preferred_order_by {
  country: order_by
  currency: order_by
  id: order_by
  issuer: order_by
  name: order_by
  rate: order_by
  resolution_date: order_by
  resolution_status: order_by
  resolution_user_id: order_by
  share_number: order_by
  source: order_by
  uid: order_by
  update_date: order_by
  update_user_id: order_by
}

"""primary key columns input for table: preferred"""
input preferred_pk_columns_input {
  id: Int!
}

"""
select columns of table "preferred"
"""
enum preferred_select_column {
  """column name"""
  country

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  issuer

  """column name"""
  name

  """column name"""
  rate

  """column name"""
  resolution_date

  """column name"""
  resolution_status

  """column name"""
  resolution_user_id

  """column name"""
  share_number

  """column name"""
  source

  """column name"""
  uid

  """column name"""
  update_date

  """column name"""
  update_user_id
}

"""
input type for updating data in table "preferred"
"""
input preferred_set_input {
  country: String
  currency: String
  id: Int
  issuer: String
  name: String
  rate: float8
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  share_number: Int
  source: String
  uid: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate stddev on columns"""
type preferred_stddev_fields {
  id: Float
  rate: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""aggregate stddev_pop on columns"""
type preferred_stddev_pop_fields {
  id: Float
  rate: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""aggregate stddev_samp on columns"""
type preferred_stddev_samp_fields {
  id: Float
  rate: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""aggregate sum on columns"""
type preferred_sum_fields {
  id: Int
  rate: float8
  resolution_user_id: Int
  share_number: Int
  update_user_id: Int
}

"""
update columns of table "preferred"
"""
enum preferred_update_column {
  """column name"""
  country

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  issuer

  """column name"""
  name

  """column name"""
  rate

  """column name"""
  resolution_date

  """column name"""
  resolution_status

  """column name"""
  resolution_user_id

  """column name"""
  share_number

  """column name"""
  source

  """column name"""
  uid

  """column name"""
  update_date

  """column name"""
  update_user_id
}

"""aggregate var_pop on columns"""
type preferred_var_pop_fields {
  id: Float
  rate: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""aggregate var_samp on columns"""
type preferred_var_samp_fields {
  id: Float
  rate: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

"""aggregate variance on columns"""
type preferred_variance_fields {
  id: Float
  rate: Float
  resolution_user_id: Float
  share_number: Float
  update_user_id: Float
}

type query_root {
  """
  fetch data from the table: "bond"
  """
  bond(
    """distinct select on columns"""
    distinct_on: [bond_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bond_order_by!]

    """filter the rows returned"""
    where: bond_bool_exp
  ): [bond!]!

  """
  fetch aggregated fields from the table: "bond"
  """
  bond_aggregate(
    """distinct select on columns"""
    distinct_on: [bond_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bond_order_by!]

    """filter the rows returned"""
    where: bond_bool_exp
  ): bond_aggregate!

  """fetch data from the table: "bond" using primary key columns"""
  bond_by_pk(id: Int!): bond

  """
  execute function "candidates" which returns "instrument"
  """
  candidates(
    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): [instrument!]!

  """
  execute function "candidates" and query aggregates on result of table type "instrument"
  """
  candidates_aggregate(
    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): instrument_aggregate!

  """
  fetch data from the table: "coupon"
  """
  coupon(
    """distinct select on columns"""
    distinct_on: [coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupon_order_by!]

    """filter the rows returned"""
    where: coupon_bool_exp
  ): [coupon!]!

  """
  fetch aggregated fields from the table: "coupon"
  """
  coupon_aggregate(
    """distinct select on columns"""
    distinct_on: [coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupon_order_by!]

    """filter the rows returned"""
    where: coupon_bool_exp
  ): coupon_aggregate!

  """fetch data from the table: "coupon" using primary key columns"""
  coupon_by_pk(id: Int!): coupon

  """
  fetch data from the table: "equity"
  """
  equity(
    """distinct select on columns"""
    distinct_on: [equity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [equity_order_by!]

    """filter the rows returned"""
    where: equity_bool_exp
  ): [equity!]!

  """
  fetch aggregated fields from the table: "equity"
  """
  equity_aggregate(
    """distinct select on columns"""
    distinct_on: [equity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [equity_order_by!]

    """filter the rows returned"""
    where: equity_bool_exp
  ): equity_aggregate!

  """fetch data from the table: "equity" using primary key columns"""
  equity_by_pk(id: Int!): equity

  """
  execute function "golden" which returns "instrument"
  """
  golden(
    """
    input parameters for function "golden"
    """
    args: golden_args!

    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): [instrument!]!

  """
  execute function "golden" and query aggregates on result of table type "instrument"
  """
  golden_aggregate(
    """
    input parameters for function "golden"
    """
    args: golden_args!

    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): instrument_aggregate!

  """
  fetch data from the table: "instrument"
  """
  instrument(
    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): [instrument!]!

  """
  fetch aggregated fields from the table: "instrument"
  """
  instrument_aggregate(
    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): instrument_aggregate!

  """fetch data from the table: "instrument" using primary key columns"""
  instrument_by_pk(id: Int!): instrument

  """
  fetch data from the table: "preferred"
  """
  preferred(
    """distinct select on columns"""
    distinct_on: [preferred_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [preferred_order_by!]

    """filter the rows returned"""
    where: preferred_bool_exp
  ): [preferred!]!

  """
  fetch aggregated fields from the table: "preferred"
  """
  preferred_aggregate(
    """distinct select on columns"""
    distinct_on: [preferred_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [preferred_order_by!]

    """filter the rows returned"""
    where: preferred_bool_exp
  ): preferred_aggregate!

  """fetch data from the table: "preferred" using primary key columns"""
  preferred_by_pk(id: Int!): preferred

  """
  fetch data from the table: "resolution"
  """
  resolution(
    """distinct select on columns"""
    distinct_on: [resolution_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resolution_order_by!]

    """filter the rows returned"""
    where: resolution_bool_exp
  ): [resolution!]!

  """
  fetch aggregated fields from the table: "resolution"
  """
  resolution_aggregate(
    """distinct select on columns"""
    distinct_on: [resolution_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resolution_order_by!]

    """filter the rows returned"""
    where: resolution_bool_exp
  ): resolution_aggregate!
}

input reject_args {
  instrument_id: Int
}

"""
columns and relationships of "resolution"
"""
type resolution {
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String!
  update_date: timestamptz!
  update_user_id: Int!
}

"""
aggregated selection of "resolution"
"""
type resolution_aggregate {
  aggregate: resolution_aggregate_fields
  nodes: [resolution!]!
}

"""
aggregate fields of "resolution"
"""
type resolution_aggregate_fields {
  avg: resolution_avg_fields
  count(columns: [resolution_select_column!], distinct: Boolean): Int!
  max: resolution_max_fields
  min: resolution_min_fields
  stddev: resolution_stddev_fields
  stddev_pop: resolution_stddev_pop_fields
  stddev_samp: resolution_stddev_samp_fields
  sum: resolution_sum_fields
  var_pop: resolution_var_pop_fields
  var_samp: resolution_var_samp_fields
  variance: resolution_variance_fields
}

"""aggregate avg on columns"""
type resolution_avg_fields {
  resolution_user_id: Float
  update_user_id: Float
}

"""
Boolean expression to filter rows from the table "resolution". All fields are combined with a logical 'AND'.
"""
input resolution_bool_exp {
  _and: [resolution_bool_exp!]
  _not: resolution_bool_exp
  _or: [resolution_bool_exp!]
  resolution_date: timestamptz_comparison_exp
  resolution_status: String_comparison_exp
  resolution_user_id: Int_comparison_exp
  source: String_comparison_exp
  update_date: timestamptz_comparison_exp
  update_user_id: Int_comparison_exp
}

"""
input type for incrementing numeric columns in table "resolution"
"""
input resolution_inc_input {
  resolution_user_id: Int
  update_user_id: Int
}

"""
input type for inserting data into table "resolution"
"""
input resolution_insert_input {
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate max on columns"""
type resolution_max_fields {
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate min on columns"""
type resolution_min_fields {
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  update_date: timestamptz
  update_user_id: Int
}

"""
response of any mutation on the table "resolution"
"""
type resolution_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [resolution!]!
}

"""Ordering options when selecting data from "resolution"."""
input resolution_order_by {
  resolution_date: order_by
  resolution_status: order_by
  resolution_user_id: order_by
  source: order_by
  update_date: order_by
  update_user_id: order_by
}

"""
select columns of table "resolution"
"""
enum resolution_select_column {
  """column name"""
  resolution_date

  """column name"""
  resolution_status

  """column name"""
  resolution_user_id

  """column name"""
  source

  """column name"""
  update_date

  """column name"""
  update_user_id
}

"""
input type for updating data in table "resolution"
"""
input resolution_set_input {
  resolution_date: timestamptz
  resolution_status: String
  resolution_user_id: Int
  source: String
  update_date: timestamptz
  update_user_id: Int
}

"""aggregate stddev on columns"""
type resolution_stddev_fields {
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate stddev_pop on columns"""
type resolution_stddev_pop_fields {
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate stddev_samp on columns"""
type resolution_stddev_samp_fields {
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate sum on columns"""
type resolution_sum_fields {
  resolution_user_id: Int
  update_user_id: Int
}

"""aggregate var_pop on columns"""
type resolution_var_pop_fields {
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate var_samp on columns"""
type resolution_var_samp_fields {
  resolution_user_id: Float
  update_user_id: Float
}

"""aggregate variance on columns"""
type resolution_variance_fields {
  resolution_user_id: Float
  update_user_id: Float
}

type subscription_root {
  """
  fetch data from the table: "bond"
  """
  bond(
    """distinct select on columns"""
    distinct_on: [bond_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bond_order_by!]

    """filter the rows returned"""
    where: bond_bool_exp
  ): [bond!]!

  """
  fetch aggregated fields from the table: "bond"
  """
  bond_aggregate(
    """distinct select on columns"""
    distinct_on: [bond_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [bond_order_by!]

    """filter the rows returned"""
    where: bond_bool_exp
  ): bond_aggregate!

  """fetch data from the table: "bond" using primary key columns"""
  bond_by_pk(id: Int!): bond

  """
  execute function "candidates" which returns "instrument"
  """
  candidates(
    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): [instrument!]!

  """
  execute function "candidates" and query aggregates on result of table type "instrument"
  """
  candidates_aggregate(
    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): instrument_aggregate!

  """
  fetch data from the table: "coupon"
  """
  coupon(
    """distinct select on columns"""
    distinct_on: [coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupon_order_by!]

    """filter the rows returned"""
    where: coupon_bool_exp
  ): [coupon!]!

  """
  fetch aggregated fields from the table: "coupon"
  """
  coupon_aggregate(
    """distinct select on columns"""
    distinct_on: [coupon_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [coupon_order_by!]

    """filter the rows returned"""
    where: coupon_bool_exp
  ): coupon_aggregate!

  """fetch data from the table: "coupon" using primary key columns"""
  coupon_by_pk(id: Int!): coupon

  """
  fetch data from the table: "equity"
  """
  equity(
    """distinct select on columns"""
    distinct_on: [equity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [equity_order_by!]

    """filter the rows returned"""
    where: equity_bool_exp
  ): [equity!]!

  """
  fetch aggregated fields from the table: "equity"
  """
  equity_aggregate(
    """distinct select on columns"""
    distinct_on: [equity_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [equity_order_by!]

    """filter the rows returned"""
    where: equity_bool_exp
  ): equity_aggregate!

  """fetch data from the table: "equity" using primary key columns"""
  equity_by_pk(id: Int!): equity

  """
  execute function "golden" which returns "instrument"
  """
  golden(
    """
    input parameters for function "golden"
    """
    args: golden_args!

    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): [instrument!]!

  """
  execute function "golden" and query aggregates on result of table type "instrument"
  """
  golden_aggregate(
    """
    input parameters for function "golden"
    """
    args: golden_args!

    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): instrument_aggregate!

  """
  fetch data from the table: "instrument"
  """
  instrument(
    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): [instrument!]!

  """
  fetch aggregated fields from the table: "instrument"
  """
  instrument_aggregate(
    """distinct select on columns"""
    distinct_on: [instrument_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [instrument_order_by!]

    """filter the rows returned"""
    where: instrument_bool_exp
  ): instrument_aggregate!

  """fetch data from the table: "instrument" using primary key columns"""
  instrument_by_pk(id: Int!): instrument

  """
  fetch data from the table: "preferred"
  """
  preferred(
    """distinct select on columns"""
    distinct_on: [preferred_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [preferred_order_by!]

    """filter the rows returned"""
    where: preferred_bool_exp
  ): [preferred!]!

  """
  fetch aggregated fields from the table: "preferred"
  """
  preferred_aggregate(
    """distinct select on columns"""
    distinct_on: [preferred_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [preferred_order_by!]

    """filter the rows returned"""
    where: preferred_bool_exp
  ): preferred_aggregate!

  """fetch data from the table: "preferred" using primary key columns"""
  preferred_by_pk(id: Int!): preferred

  """
  fetch data from the table: "resolution"
  """
  resolution(
    """distinct select on columns"""
    distinct_on: [resolution_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resolution_order_by!]

    """filter the rows returned"""
    where: resolution_bool_exp
  ): [resolution!]!

  """
  fetch aggregated fields from the table: "resolution"
  """
  resolution_aggregate(
    """distinct select on columns"""
    distinct_on: [resolution_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [resolution_order_by!]

    """filter the rows returned"""
    where: resolution_bool_exp
  ): resolution_aggregate!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}
